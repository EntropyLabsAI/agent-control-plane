/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Sentinel API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
export type CreateRunToolBodyAttributes = { [key: string]: unknown };

export type CreateRunToolBody = {
  attributes?: CreateRunToolBodyAttributes;
  description?: string;
  ignored_attributes?: string[];
  name: string;
};

export type CreateProjectBody = {
  name: string;
};

export type MessageRole = typeof MessageRole[keyof typeof MessageRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageRole = {
  system: 'system',
  user: 'user',
  assistant: 'assistant',
} as const;

export type HubStatsReviewDistribution = {[key: string]: number};

export type HubStatsAssignedReviews = {[key: string]: number};

export interface HubStats {
  assigned_reviews: HubStatsAssignedReviews;
  assigned_reviews_count: number;
  busy_clients: number;
  completed_reviews_count: number;
  connected_clients: number;
  free_clients: number;
  pending_reviews_count: number;
  review_distribution: HubStatsReviewDistribution;
}

export interface Usage {
  input_tokens: number;
  output_tokens: number;
  total_tokens: number;
}

export type ToolCallArguments = { [key: string]: unknown };

export interface ToolCall {
  arguments: ToolCallArguments;
  function: string;
  id: string;
  parse_error?: string;
  type: string;
}

export interface AssistantMessage {
  content: string;
  role: string;
  source?: string;
  tool_calls?: ToolCall[];
}

export interface Choice {
  message: AssistantMessage;
  stop_reason?: string;
}

export interface Output {
  choices?: Choice[];
  model?: string;
  usage?: Usage;
}

export interface ToolChoice {
  arguments: Arguments;
  function: string;
  id: string;
  type: string;
}

export interface StateMessage {
  content: string;
  function?: string;
  role: string;
  source?: string;
  tool_call_id?: string;
  tool_calls?: ToolCall[];
}

export type TaskStateStore = { [key: string]: unknown };

export type TaskStateMetadata = { [key: string]: unknown };

export interface TaskState {
  completed: boolean;
  messages: StateMessage[];
  metadata?: TaskStateMetadata;
  output: Output;
  store?: TaskStateStore;
  tool_choice?: ToolChoice;
  tools: Tool[];
}

/**
 * The type of supervisor. ClientSupervisor means that the supervision is done client side and the server is merely informed. Other supervisor types are handled serverside, e.g. HumanSupervisor means that a human will review the request via the Sentinel UI.
 */
export type SupervisorType = typeof SupervisorType[keyof typeof SupervisorType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SupervisorType = {
  client_supervisor: 'client_supervisor',
  human_supervisor: 'human_supervisor',
  no_supervisor: 'no_supervisor',
} as const;

export type Decision = typeof Decision[keyof typeof Decision];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Decision = {
  approve: 'approve',
  reject: 'reject',
  terminate: 'terminate',
  modify: 'modify',
  escalate: 'escalate',
} as const;

export type Status = typeof Status[keyof typeof Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Status = {
  pending: 'pending',
  completed: 'completed',
  failed: 'failed',
  assigned: 'assigned',
  timeout: 'timeout',
} as const;

export interface SupervisionResult {
  created_at: string;
  decision: Decision;
  id?: string;
  reasoning: string;
  supervision_request_id: string;
}

export interface SupervisionStatus {
  created_at: string;
  id: number;
  status: Status;
  supervision_request_id?: string;
}

export interface SupervisionRequest {
  chainexecution_id: string;
  id?: string;
  position_in_chain: number;
  status?: SupervisionStatus;
  supervisor_id: string;
}

export interface Arguments { [key: string]: unknown }

export interface Message {
  content: string;
  role: MessageRole;
}

export interface ToolRequest {
  arguments: Arguments;
  id?: string;
  message: Message;
  requestgroup_id?: string;
  task_state: TaskState;
  tool_id: string;
}

export interface ToolRequestGroup {
  created_at?: string;
  id?: string;
  tool_requests: ToolRequest[];
}

export interface SupervisorChain {
  chain_id: string;
  supervisors: Supervisor[];
}

export interface ChainRequest {
  /** Array of supervisor IDs to create chains with */
  supervisor_ids?: string[];
}

export type SupervisorAttributes = { [key: string]: unknown };

export interface Supervisor {
  attributes: SupervisorAttributes;
  code: string;
  created_at: string;
  description: string;
  id?: string;
  name: string;
  type: SupervisorType;
}

export type ToolAttributes = { [key: string]: unknown };

export interface Tool {
  attributes?: ToolAttributes;
  description?: string;
  id?: string;
  ignored_attributes?: string[];
  name?: string;
  run_id?: string;
}

export interface Run {
  created_at: string;
  id: string;
  project_id: string;
}

export interface Project {
  created_at: string;
  id: string;
  name: string;
}

export interface SupervisionRequestState {
  result?: SupervisionResult;
  status: SupervisionStatus;
  supervision_request: SupervisionRequest;
}

export interface ChainState {
  chain: SupervisorChain;
  supervision_requests: SupervisionRequestState[];
}

export interface RunExecution {
  chains: ChainState[];
  request_group: ToolRequestGroup;
}

export type RunState = RunExecution[];

export interface ErrorResponse {
  details?: string;
  error: string;
}





/**
 * @summary Get the OpenAPI schema
 */
export const getOpenAPI = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/openapi.yaml`,options
    );
  }


export const getGetOpenAPIQueryKey = () => {
    return [`/api/openapi.yaml`] as const;
    }

    
export const getGetOpenAPIQueryOptions = <TData = Awaited<ReturnType<typeof getOpenAPI>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getOpenAPI>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOpenAPIQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOpenAPI>>> = ({ signal }) => getOpenAPI({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOpenAPI>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOpenAPIQueryResult = NonNullable<Awaited<ReturnType<typeof getOpenAPI>>>
export type GetOpenAPIQueryError = AxiosError<unknown>

/**
 * @summary Get the OpenAPI schema
 */
export const useGetOpenAPI = <TData = Awaited<ReturnType<typeof getOpenAPI>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getOpenAPI>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOpenAPIQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get the Swagger UI
 */
export const getSwaggerDocs = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/swagger-ui`,options
    );
  }


export const getGetSwaggerDocsQueryKey = () => {
    return [`/api/swagger-ui`] as const;
    }

    
export const getGetSwaggerDocsQueryOptions = <TData = Awaited<ReturnType<typeof getSwaggerDocs>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSwaggerDocs>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSwaggerDocsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSwaggerDocs>>> = ({ signal }) => getSwaggerDocs({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSwaggerDocs>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSwaggerDocsQueryResult = NonNullable<Awaited<ReturnType<typeof getSwaggerDocs>>>
export type GetSwaggerDocsQueryError = AxiosError<unknown>

/**
 * @summary Get the Swagger UI
 */
export const useGetSwaggerDocs = <TData = Awaited<ReturnType<typeof getSwaggerDocs>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSwaggerDocs>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSwaggerDocsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all projects
 */
export const getProjects = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Project[]>> => {
    
    return axios.get(
      `/api/project`,options
    );
  }


export const getGetProjectsQueryKey = () => {
    return [`/api/project`] as const;
    }

    
export const getGetProjectsQueryOptions = <TData = Awaited<ReturnType<typeof getProjects>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjects>>> = ({ signal }) => getProjects({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectsQueryResult = NonNullable<Awaited<ReturnType<typeof getProjects>>>
export type GetProjectsQueryError = AxiosError<unknown>

/**
 * @summary Get all projects
 */
export const useGetProjects = <TData = Awaited<ReturnType<typeof getProjects>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new project
 */
export const createProject = (
    createProjectBody: CreateProjectBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/api/project`,
      createProjectBody,options
    );
  }



export const getCreateProjectMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: CreateProjectBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: CreateProjectBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProject>>, {data: CreateProjectBody}> = (props) => {
          const {data} = props ?? {};

          return  createProject(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProjectMutationResult = NonNullable<Awaited<ReturnType<typeof createProject>>>
    export type CreateProjectMutationBody = CreateProjectBody
    export type CreateProjectMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a new project
 */
export const useCreateProject = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: CreateProjectBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createProject>>,
        TError,
        {data: CreateProjectBody},
        TContext
      > => {

      const mutationOptions = getCreateProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a project
 */
export const getProject = (
    projectId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Project>> => {
    
    return axios.get(
      `/api/project/${projectId}`,options
    );
  }


export const getGetProjectQueryKey = (projectId: string,) => {
    return [`/api/project/${projectId}`] as const;
    }

    
export const getGetProjectQueryOptions = <TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({ signal }) => getProject(projectId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectQueryResult = NonNullable<Awaited<ReturnType<typeof getProject>>>
export type GetProjectQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get a project
 */
export const useGetProject = <TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(
 projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectQueryOptions(projectId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all runs for a project
 */
export const getProjectRuns = (
    projectId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Run[]>> => {
    
    return axios.get(
      `/api/project/${projectId}/run`,options
    );
  }


export const getGetProjectRunsQueryKey = (projectId: string,) => {
    return [`/api/project/${projectId}/run`] as const;
    }

    
export const getGetProjectRunsQueryOptions = <TData = Awaited<ReturnType<typeof getProjectRuns>>, TError = AxiosError<unknown>>(projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectRuns>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectRunsQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectRuns>>> = ({ signal }) => getProjectRuns(projectId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjectRuns>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectRunsQueryResult = NonNullable<Awaited<ReturnType<typeof getProjectRuns>>>
export type GetProjectRunsQueryError = AxiosError<unknown>

/**
 * @summary Get all runs for a project
 */
export const useGetProjectRuns = <TData = Awaited<ReturnType<typeof getProjectRuns>>, TError = AxiosError<unknown>>(
 projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectRuns>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectRunsQueryOptions(projectId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new run for a project
 */
export const createProjectRun = (
    projectId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/api/project/${projectId}/run`,undefined,options
    );
  }



export const getCreateProjectRunMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProjectRun>>, TError,{projectId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createProjectRun>>, TError,{projectId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProjectRun>>, {projectId: string}> = (props) => {
          const {projectId} = props ?? {};

          return  createProjectRun(projectId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProjectRunMutationResult = NonNullable<Awaited<ReturnType<typeof createProjectRun>>>
    
    export type CreateProjectRunMutationError = AxiosError<unknown>

    /**
 * @summary Create a new run for a project
 */
export const useCreateProjectRun = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProjectRun>>, TError,{projectId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createProjectRun>>,
        TError,
        {projectId: string},
        TContext
      > => {

      const mutationOptions = getCreateProjectRunMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all tools for a run
 */
export const getRunTools = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tool[]>> => {
    
    return axios.get(
      `/api/run/${runId}/tool`,options
    );
  }


export const getGetRunToolsQueryKey = (runId: string,) => {
    return [`/api/run/${runId}/tool`] as const;
    }

    
export const getGetRunToolsQueryOptions = <TData = Awaited<ReturnType<typeof getRunTools>>, TError = AxiosError<unknown>>(runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunTools>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunToolsQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunTools>>> = ({ signal }) => getRunTools(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRunTools>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRunToolsQueryResult = NonNullable<Awaited<ReturnType<typeof getRunTools>>>
export type GetRunToolsQueryError = AxiosError<unknown>

/**
 * @summary Get all tools for a run
 */
export const useGetRunTools = <TData = Awaited<ReturnType<typeof getRunTools>>, TError = AxiosError<unknown>>(
 runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunTools>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRunToolsQueryOptions(runId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new tool for a run
 */
export const createRunTool = (
    runId: string,
    createRunToolBody: CreateRunToolBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/api/run/${runId}/tool`,
      createRunToolBody,options
    );
  }



export const getCreateRunToolMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRunTool>>, TError,{runId: string;data: CreateRunToolBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createRunTool>>, TError,{runId: string;data: CreateRunToolBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRunTool>>, {runId: string;data: CreateRunToolBody}> = (props) => {
          const {runId,data} = props ?? {};

          return  createRunTool(runId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRunToolMutationResult = NonNullable<Awaited<ReturnType<typeof createRunTool>>>
    export type CreateRunToolMutationBody = CreateRunToolBody
    export type CreateRunToolMutationError = AxiosError<unknown>

    /**
 * @summary Create a new tool for a run
 */
export const useCreateRunTool = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRunTool>>, TError,{runId: string;data: CreateRunToolBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createRunTool>>,
        TError,
        {runId: string;data: CreateRunToolBody},
        TContext
      > => {

      const mutationOptions = getCreateRunToolMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a supervisor
 */
export const getSupervisor = (
    supervisorId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Supervisor>> => {
    
    return axios.get(
      `/api/supervisor/${supervisorId}`,options
    );
  }


export const getGetSupervisorQueryKey = (supervisorId: string,) => {
    return [`/api/supervisor/${supervisorId}`] as const;
    }

    
export const getGetSupervisorQueryOptions = <TData = Awaited<ReturnType<typeof getSupervisor>>, TError = AxiosError<unknown>>(supervisorId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisor>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupervisorQueryKey(supervisorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupervisor>>> = ({ signal }) => getSupervisor(supervisorId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(supervisorId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSupervisor>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSupervisorQueryResult = NonNullable<Awaited<ReturnType<typeof getSupervisor>>>
export type GetSupervisorQueryError = AxiosError<unknown>

/**
 * @summary Get a supervisor
 */
export const useGetSupervisor = <TData = Awaited<ReturnType<typeof getSupervisor>>, TError = AxiosError<unknown>>(
 supervisorId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisor>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSupervisorQueryOptions(supervisorId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all supervisors
 */
export const getSupervisors = (
    projectId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Supervisor[]>> => {
    
    return axios.get(
      `/api/project/${projectId}/supervisor`,options
    );
  }


export const getGetSupervisorsQueryKey = (projectId: string,) => {
    return [`/api/project/${projectId}/supervisor`] as const;
    }

    
export const getGetSupervisorsQueryOptions = <TData = Awaited<ReturnType<typeof getSupervisors>>, TError = AxiosError<unknown>>(projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisors>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupervisorsQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupervisors>>> = ({ signal }) => getSupervisors(projectId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSupervisors>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSupervisorsQueryResult = NonNullable<Awaited<ReturnType<typeof getSupervisors>>>
export type GetSupervisorsQueryError = AxiosError<unknown>

/**
 * @summary Get all supervisors
 */
export const useGetSupervisors = <TData = Awaited<ReturnType<typeof getSupervisors>>, TError = AxiosError<unknown>>(
 projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisors>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSupervisorsQueryOptions(projectId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new supervisor
 */
export const createSupervisor = (
    projectId: string,
    supervisor: Supervisor, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/api/project/${projectId}/supervisor`,
      supervisor,options
    );
  }



export const getCreateSupervisorMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisor>>, TError,{projectId: string;data: Supervisor}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createSupervisor>>, TError,{projectId: string;data: Supervisor}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSupervisor>>, {projectId: string;data: Supervisor}> = (props) => {
          const {projectId,data} = props ?? {};

          return  createSupervisor(projectId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSupervisorMutationResult = NonNullable<Awaited<ReturnType<typeof createSupervisor>>>
    export type CreateSupervisorMutationBody = Supervisor
    export type CreateSupervisorMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a new supervisor
 */
export const useCreateSupervisor = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisor>>, TError,{projectId: string;data: Supervisor}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createSupervisor>>,
        TError,
        {projectId: string;data: Supervisor},
        TContext
      > => {

      const mutationOptions = getCreateSupervisorMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all supervisors for a tool, in chain format
 */
export const getToolSupervisorChains = (
    toolId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SupervisorChain[]>> => {
    
    return axios.get(
      `/api/tool/${toolId}/supervisors`,options
    );
  }


export const getGetToolSupervisorChainsQueryKey = (toolId: string,) => {
    return [`/api/tool/${toolId}/supervisors`] as const;
    }

    
export const getGetToolSupervisorChainsQueryOptions = <TData = Awaited<ReturnType<typeof getToolSupervisorChains>>, TError = AxiosError<unknown>>(toolId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getToolSupervisorChains>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetToolSupervisorChainsQueryKey(toolId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getToolSupervisorChains>>> = ({ signal }) => getToolSupervisorChains(toolId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(toolId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getToolSupervisorChains>>, TError, TData> & { queryKey: QueryKey }
}

export type GetToolSupervisorChainsQueryResult = NonNullable<Awaited<ReturnType<typeof getToolSupervisorChains>>>
export type GetToolSupervisorChainsQueryError = AxiosError<unknown>

/**
 * @summary Get all supervisors for a tool, in chain format
 */
export const useGetToolSupervisorChains = <TData = Awaited<ReturnType<typeof getToolSupervisorChains>>, TError = AxiosError<unknown>>(
 toolId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getToolSupervisorChains>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetToolSupervisorChainsQueryOptions(toolId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create new chains with supervisors for a tool
 */
export const createToolSupervisorChains = (
    toolId: string,
    chainRequest: ChainRequest[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string[]>> => {
    
    return axios.post(
      `/api/tool/${toolId}/supervisors`,
      chainRequest,options
    );
  }



export const getCreateToolSupervisorChainsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createToolSupervisorChains>>, TError,{toolId: string;data: ChainRequest[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createToolSupervisorChains>>, TError,{toolId: string;data: ChainRequest[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createToolSupervisorChains>>, {toolId: string;data: ChainRequest[]}> = (props) => {
          const {toolId,data} = props ?? {};

          return  createToolSupervisorChains(toolId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateToolSupervisorChainsMutationResult = NonNullable<Awaited<ReturnType<typeof createToolSupervisorChains>>>
    export type CreateToolSupervisorChainsMutationBody = ChainRequest[]
    export type CreateToolSupervisorChainsMutationError = AxiosError<unknown>

    /**
 * @summary Create new chains with supervisors for a tool
 */
export const useCreateToolSupervisorChains = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createToolSupervisorChains>>, TError,{toolId: string;data: ChainRequest[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createToolSupervisorChains>>,
        TError,
        {toolId: string;data: ChainRequest[]},
        TContext
      > => {

      const mutationOptions = getCreateToolSupervisorChainsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Create a new request group for a tool
 */
export const createToolRequestGroup = (
    toolId: string,
    toolRequestGroup: ToolRequestGroup, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/api/tool/${toolId}/request_group`,
      toolRequestGroup,options
    );
  }



export const getCreateToolRequestGroupMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createToolRequestGroup>>, TError,{toolId: string;data: ToolRequestGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createToolRequestGroup>>, TError,{toolId: string;data: ToolRequestGroup}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createToolRequestGroup>>, {toolId: string;data: ToolRequestGroup}> = (props) => {
          const {toolId,data} = props ?? {};

          return  createToolRequestGroup(toolId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateToolRequestGroupMutationResult = NonNullable<Awaited<ReturnType<typeof createToolRequestGroup>>>
    export type CreateToolRequestGroupMutationBody = ToolRequestGroup
    export type CreateToolRequestGroupMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a new request group for a tool
 */
export const useCreateToolRequestGroup = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createToolRequestGroup>>, TError,{toolId: string;data: ToolRequestGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createToolRequestGroup>>,
        TError,
        {toolId: string;data: ToolRequestGroup},
        TContext
      > => {

      const mutationOptions = getCreateToolRequestGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all request groups for a run
 */
export const getRunRequestGroups = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ToolRequestGroup[]>> => {
    
    return axios.get(
      `/api/run/${runId}/request_groups`,options
    );
  }


export const getGetRunRequestGroupsQueryKey = (runId: string,) => {
    return [`/api/run/${runId}/request_groups`] as const;
    }

    
export const getGetRunRequestGroupsQueryOptions = <TData = Awaited<ReturnType<typeof getRunRequestGroups>>, TError = AxiosError<unknown>>(runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunRequestGroups>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunRequestGroupsQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunRequestGroups>>> = ({ signal }) => getRunRequestGroups(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRunRequestGroups>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRunRequestGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof getRunRequestGroups>>>
export type GetRunRequestGroupsQueryError = AxiosError<unknown>

/**
 * @summary Get all request groups for a run
 */
export const useGetRunRequestGroups = <TData = Awaited<ReturnType<typeof getRunRequestGroups>>, TError = AxiosError<unknown>>(
 runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunRequestGroups>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRunRequestGroupsQueryOptions(runId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a request group
 */
export const getRequestGroup = (
    requestGroupId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ToolRequestGroup>> => {
    
    return axios.get(
      `/api/request_group/${requestGroupId}`,options
    );
  }


export const getGetRequestGroupQueryKey = (requestGroupId: string,) => {
    return [`/api/request_group/${requestGroupId}`] as const;
    }

    
export const getGetRequestGroupQueryOptions = <TData = Awaited<ReturnType<typeof getRequestGroup>>, TError = AxiosError<unknown>>(requestGroupId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRequestGroup>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRequestGroupQueryKey(requestGroupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRequestGroup>>> = ({ signal }) => getRequestGroup(requestGroupId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(requestGroupId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRequestGroup>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRequestGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getRequestGroup>>>
export type GetRequestGroupQueryError = AxiosError<unknown>

/**
 * @summary Get a request group
 */
export const useGetRequestGroup = <TData = Awaited<ReturnType<typeof getRequestGroup>>, TError = AxiosError<unknown>>(
 requestGroupId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRequestGroup>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRequestGroupQueryOptions(requestGroupId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a tool
 */
export const getTool = (
    toolId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tool>> => {
    
    return axios.get(
      `/api/tool/${toolId}`,options
    );
  }


export const getGetToolQueryKey = (toolId: string,) => {
    return [`/api/tool/${toolId}`] as const;
    }

    
export const getGetToolQueryOptions = <TData = Awaited<ReturnType<typeof getTool>>, TError = AxiosError<ErrorResponse>>(toolId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTool>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetToolQueryKey(toolId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTool>>> = ({ signal }) => getTool(toolId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(toolId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTool>>, TError, TData> & { queryKey: QueryKey }
}

export type GetToolQueryResult = NonNullable<Awaited<ReturnType<typeof getTool>>>
export type GetToolQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get a tool
 */
export const useGetTool = <TData = Awaited<ReturnType<typeof getTool>>, TError = AxiosError<ErrorResponse>>(
 toolId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTool>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetToolQueryOptions(toolId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all tools for a project
 */
export const getProjectTools = (
    projectId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tool[]>> => {
    
    return axios.get(
      `/api/project/${projectId}/tools`,options
    );
  }


export const getGetProjectToolsQueryKey = (projectId: string,) => {
    return [`/api/project/${projectId}/tools`] as const;
    }

    
export const getGetProjectToolsQueryOptions = <TData = Awaited<ReturnType<typeof getProjectTools>>, TError = AxiosError<unknown>>(projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectTools>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectToolsQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectTools>>> = ({ signal }) => getProjectTools(projectId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjectTools>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectToolsQueryResult = NonNullable<Awaited<ReturnType<typeof getProjectTools>>>
export type GetProjectToolsQueryError = AxiosError<unknown>

/**
 * @summary Get all tools for a project
 */
export const useGetProjectTools = <TData = Awaited<ReturnType<typeof getProjectTools>>, TError = AxiosError<unknown>>(
 projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectTools>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectToolsQueryOptions(projectId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a supervision request for a supervisor in a chain on a request group
 */
export const createSupervisionRequest = (
    requestGroupId: string,
    chainId: string,
    supervisorId: string,
    supervisionRequest: SupervisionRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/api/request_group/${requestGroupId}/chain/${chainId}/supervisor/${supervisorId}/supervision_request`,
      supervisionRequest,options
    );
  }



export const getCreateSupervisionRequestMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisionRequest>>, TError,{requestGroupId: string;chainId: string;supervisorId: string;data: SupervisionRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createSupervisionRequest>>, TError,{requestGroupId: string;chainId: string;supervisorId: string;data: SupervisionRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSupervisionRequest>>, {requestGroupId: string;chainId: string;supervisorId: string;data: SupervisionRequest}> = (props) => {
          const {requestGroupId,chainId,supervisorId,data} = props ?? {};

          return  createSupervisionRequest(requestGroupId,chainId,supervisorId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSupervisionRequestMutationResult = NonNullable<Awaited<ReturnType<typeof createSupervisionRequest>>>
    export type CreateSupervisionRequestMutationBody = SupervisionRequest
    export type CreateSupervisionRequestMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a supervision request for a supervisor in a chain on a request group
 */
export const useCreateSupervisionRequest = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisionRequest>>, TError,{requestGroupId: string;chainId: string;supervisorId: string;data: SupervisionRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createSupervisionRequest>>,
        TError,
        {requestGroupId: string;chainId: string;supervisorId: string;data: SupervisionRequest},
        TContext
      > => {

      const mutationOptions = getCreateSupervisionRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a supervision request status
 */
export const getSupervisionRequestStatus = (
    supervisionRequestId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SupervisionStatus>> => {
    
    return axios.get(
      `/api/supervision_request/${supervisionRequestId}/status`,options
    );
  }


export const getGetSupervisionRequestStatusQueryKey = (supervisionRequestId: string,) => {
    return [`/api/supervision_request/${supervisionRequestId}/status`] as const;
    }

    
export const getGetSupervisionRequestStatusQueryOptions = <TData = Awaited<ReturnType<typeof getSupervisionRequestStatus>>, TError = AxiosError<unknown>>(supervisionRequestId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisionRequestStatus>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupervisionRequestStatusQueryKey(supervisionRequestId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupervisionRequestStatus>>> = ({ signal }) => getSupervisionRequestStatus(supervisionRequestId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(supervisionRequestId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSupervisionRequestStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSupervisionRequestStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getSupervisionRequestStatus>>>
export type GetSupervisionRequestStatusQueryError = AxiosError<unknown>

/**
 * @summary Get a supervision request status
 */
export const useGetSupervisionRequestStatus = <TData = Awaited<ReturnType<typeof getSupervisionRequestStatus>>, TError = AxiosError<unknown>>(
 supervisionRequestId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisionRequestStatus>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSupervisionRequestStatusQueryOptions(supervisionRequestId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a supervision result
 */
export const getSupervisionResult = (
    supervisionRequestId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SupervisionResult>> => {
    
    return axios.get(
      `/api/supervision_request/${supervisionRequestId}/result`,options
    );
  }


export const getGetSupervisionResultQueryKey = (supervisionRequestId: string,) => {
    return [`/api/supervision_request/${supervisionRequestId}/result`] as const;
    }

    
export const getGetSupervisionResultQueryOptions = <TData = Awaited<ReturnType<typeof getSupervisionResult>>, TError = AxiosError<unknown>>(supervisionRequestId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisionResult>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupervisionResultQueryKey(supervisionRequestId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupervisionResult>>> = ({ signal }) => getSupervisionResult(supervisionRequestId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(supervisionRequestId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSupervisionResult>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSupervisionResultQueryResult = NonNullable<Awaited<ReturnType<typeof getSupervisionResult>>>
export type GetSupervisionResultQueryError = AxiosError<unknown>

/**
 * @summary Get a supervision result
 */
export const useGetSupervisionResult = <TData = Awaited<ReturnType<typeof getSupervisionResult>>, TError = AxiosError<unknown>>(
 supervisionRequestId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisionResult>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSupervisionResultQueryOptions(supervisionRequestId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a supervision result for a supervision request
 */
export const createSupervisionResult = (
    supervisionRequestId: string,
    supervisionResult: SupervisionResult, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SupervisionResult>> => {
    
    return axios.post(
      `/api/supervision_request/${supervisionRequestId}/result`,
      supervisionResult,options
    );
  }



export const getCreateSupervisionResultMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisionResult>>, TError,{supervisionRequestId: string;data: SupervisionResult}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createSupervisionResult>>, TError,{supervisionRequestId: string;data: SupervisionResult}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSupervisionResult>>, {supervisionRequestId: string;data: SupervisionResult}> = (props) => {
          const {supervisionRequestId,data} = props ?? {};

          return  createSupervisionResult(supervisionRequestId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSupervisionResultMutationResult = NonNullable<Awaited<ReturnType<typeof createSupervisionResult>>>
    export type CreateSupervisionResultMutationBody = SupervisionResult
    export type CreateSupervisionResultMutationError = AxiosError<unknown>

    /**
 * @summary Create a supervision result for a supervision request
 */
export const useCreateSupervisionResult = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisionResult>>, TError,{supervisionRequestId: string;data: SupervisionResult}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createSupervisionResult>>,
        TError,
        {supervisionRequestId: string;data: SupervisionResult},
        TContext
      > => {

      const mutationOptions = getCreateSupervisionResultMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the state of a run
 */
export const getRunState = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RunState>> => {
    
    return axios.get(
      `/api/run/${runId}/state`,options
    );
  }


export const getGetRunStateQueryKey = (runId: string,) => {
    return [`/api/run/${runId}/state`] as const;
    }

    
export const getGetRunStateQueryOptions = <TData = Awaited<ReturnType<typeof getRunState>>, TError = AxiosError<unknown>>(runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunState>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunStateQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunState>>> = ({ signal }) => getRunState(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRunState>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRunStateQueryResult = NonNullable<Awaited<ReturnType<typeof getRunState>>>
export type GetRunStateQueryError = AxiosError<unknown>

/**
 * @summary Get the state of a run
 */
export const useGetRunState = <TData = Awaited<ReturnType<typeof getRunState>>, TError = AxiosError<unknown>>(
 runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunState>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRunStateQueryOptions(runId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get hub stats
 */
export const getHubStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<HubStats>> => {
    
    return axios.get(
      `/api/stats`,options
    );
  }


export const getGetHubStatsQueryKey = () => {
    return [`/api/stats`] as const;
    }

    
export const getGetHubStatsQueryOptions = <TData = Awaited<ReturnType<typeof getHubStats>>, TError = AxiosError<ErrorResponse>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHubStats>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHubStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHubStats>>> = ({ signal }) => getHubStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHubStats>>, TError, TData> & { queryKey: QueryKey }
}

export type GetHubStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getHubStats>>>
export type GetHubStatsQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get hub stats
 */
export const useGetHubStats = <TData = Awaited<ReturnType<typeof getHubStats>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHubStats>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetHubStatsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




