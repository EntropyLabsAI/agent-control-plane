/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Sentinel API
 * Version 1 of the Sentinel API
 * OpenAPI spec version: v1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
export type UpdateRunResultBody = {
  result?: string;
};

export type CreateRunToolBodyAttributes = { [key: string]: unknown };

export type CreateRunToolBody = {
  attributes: CreateRunToolBodyAttributes;
  code: string;
  description: string;
  ignored_attributes?: string[];
  name: string;
};

export type CreateTaskBody = {
  description?: string;
  name: string;
};

export type CreateProjectBody = {
  name: string;
  run_result_tags: string[];
};

export interface ToolCallIds {
  tool_call_id?: string;
  tool_id?: string;
}

export interface ChoiceIds {
  choice_id: string;
  message_id: string;
  tool_call_ids: ToolCallIds[];
}

export interface ChatIds {
  chat_id: string;
  choice_ids: ChoiceIds[];
}

export type SentinelChoiceFinishReason = typeof SentinelChoiceFinishReason[keyof typeof SentinelChoiceFinishReason];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SentinelChoiceFinishReason = {
  stop: 'stop',
  length: 'length',
  function_call: 'function_call',
  tool_calls: 'tool_calls',
  content_filter: 'content_filter',
} as const;

export interface SentinelChoice {
  finish_reason: SentinelChoiceFinishReason;
  index: number;
  message: SentinelMessage;
  sentinel_id: string;
}

export interface SentinelToolCall {
  /** Arguments in JSON format */
  arguments?: string;
  call_id?: string;
  created_at?: string;
  id: string;
  name?: string;
  tool_id: string;
}

export type SentinelMessageRole = typeof SentinelMessageRole[keyof typeof SentinelMessageRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SentinelMessageRole = {
  system: 'system',
  user: 'user',
  assistant: 'assistant',
  function: 'function',
  tool: 'tool',
  sentinel: 'sentinel',
} as const;

export interface SentinelMessage {
  content: string;
  created_at?: string;
  /** The raw b64 encoded JSON of the message objects in its original form */
  data?: string;
  id?: string;
  role: SentinelMessageRole;
  tool_calls?: SentinelToolCall[];
  /** The type of content in the message, either text or b64 encoded audio */
  type?: MessageType;
}

/**
 * The raw b64 encoded JSON of the request and response data sent/received from the LLM.
 */
export interface SentinelChat {
  request_data: string;
  response_data: string;
}

export interface Task {
  created_at: string;
  description?: string;
  id: string;
  name: string;
  project_id: string;
}

/**
 * Contains all the information needed for a human reviewer to make a supervision decision
 */
export interface ReviewPayload {
  /** The state of the entire supervision chain, including previous supervision results */
  chain_state: ChainExecutionState;
  /** The ID of the run this review is for */
  run_id: string;
  /** The current supervision request being reviewed */
  supervision_request: SupervisionRequest;
  /** The tool call being supervised */
  toolcall?: ToolCall;
}

export type MessageRole = typeof MessageRole[keyof typeof MessageRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageRole = {
  system: 'system',
  user: 'user',
  assistant: 'assistant',
} as const;

export type HubStatsReviewDistribution = {[key: string]: number};

export type HubStatsAssignedReviews = {[key: string]: number};

export interface HubStats {
  assigned_reviews: HubStatsAssignedReviews;
  assigned_reviews_count: number;
  busy_clients: number;
  completed_reviews_count: number;
  connected_clients: number;
  free_clients: number;
  pending_reviews_count: number;
  review_distribution: HubStatsReviewDistribution;
}

export interface Usage {
  input_tokens: number;
  output_tokens: number;
  total_tokens: number;
}

export interface Output {
  choices?: Choice[];
  model?: string;
  usage?: Usage;
}

export interface ToolChoice {
  arguments: Arguments;
  function: string;
  id: string;
  type: string;
}

export type TaskStateStore = { [key: string]: unknown };

export type TaskStateMetadata = { [key: string]: unknown };

export interface TaskState {
  completed: boolean;
  messages: Message[];
  metadata?: TaskStateMetadata;
  output: Output;
  store?: TaskStateStore;
  tool_choice?: ToolChoice;
  tools: Tool[];
}

/**
 * The type of supervisor. ClientSupervisor means that the supervision is done client side and the server is merely informed. Other supervisor types are handled serverside, e.g. HumanSupervisor means that a human will review the request via the Sentinel UI.
 */
export type SupervisorType = typeof SupervisorType[keyof typeof SupervisorType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SupervisorType = {
  client_supervisor: 'client_supervisor',
  human_supervisor: 'human_supervisor',
  no_supervisor: 'no_supervisor',
} as const;

export type Decision = typeof Decision[keyof typeof Decision];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Decision = {
  approve: 'approve',
  reject: 'reject',
  terminate: 'terminate',
  modify: 'modify',
  escalate: 'escalate',
} as const;

export type Status = typeof Status[keyof typeof Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Status = {
  pending: 'pending',
  completed: 'completed',
  failed: 'failed',
  assigned: 'assigned',
  timeout: 'timeout',
} as const;

export interface SupervisionResult {
  created_at: string;
  decision: Decision;
  id?: string;
  reasoning: string;
  supervision_request_id: string;
  toolcall_id?: string;
}

export interface SupervisionStatus {
  created_at: string;
  id: number;
  status: Status;
  supervision_request_id?: string;
}

export interface SupervisionRequest {
  chainexecution_id?: string;
  id?: string;
  position_in_chain: number;
  status?: SupervisionStatus;
  supervisor_id: string;
}

export interface Arguments { [key: string]: unknown }

export type MessageType = typeof MessageType[keyof typeof MessageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageType = {
  text: 'text',
  audio: 'audio',
  image: 'image',
  image_url: 'image_url',
} as const;

export type ToolCallArguments = { [key: string]: unknown };

export interface ToolCall {
  arguments: ToolCallArguments;
  function: string;
  id: string;
  parse_error?: string;
  type: string;
}

export interface Message {
  content: string;
  id?: string;
  role: MessageRole;
  source?: string;
  tool_calls?: ToolCall[];
  type?: MessageType;
}

export interface Choice {
  message: Message;
  stop_reason?: string;
}

export interface SupervisorChain {
  chain_id: string;
  supervisors: Supervisor[];
}

export interface ChainRequest {
  /** Array of supervisor IDs to create chains with */
  supervisor_ids?: string[];
}

export type SupervisorAttributes = { [key: string]: unknown };

export interface Supervisor {
  attributes: SupervisorAttributes;
  code: string;
  created_at: string;
  description: string;
  id?: string;
  name: string;
  type: SupervisorType;
}

export type ToolAttributes = { [key: string]: unknown };

export interface Tool {
  attributes: ToolAttributes;
  code: string;
  description: string;
  id?: string;
  ignored_attributes?: string[];
  name: string;
  run_id: string;
}

export interface Run {
  created_at: string;
  id: string;
  result?: string;
  status?: Status;
  task_id: string;
}

export interface Project {
  created_at: string;
  id: string;
  name: string;
  run_result_tags: string[];
}

export interface SupervisionRequestState {
  result?: SupervisionResult;
  status: SupervisionStatus;
  supervision_request: SupervisionRequest;
}

export interface ChainExecution {
  chain_id: string;
  created_at: string;
  id: string;
  toolcall_id: string;
}

export interface ChainExecutionState {
  chain: SupervisorChain;
  chain_execution: ChainExecution;
  supervision_requests: SupervisionRequestState[];
}

export interface RunExecution {
  chains: ChainExecutionState[];
  status: Status;
  toolcall: SentinelToolCall;
}

export type RunState = RunExecution[];

export interface ErrorResponse {
  details?: string;
  error: string;
}





/**
 * @summary Get the OpenAPI schema
 */
export const getOpenAPI = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/openapi.yaml`,options
    );
  }


export const getGetOpenAPIQueryKey = () => {
    return [`/openapi.yaml`] as const;
    }

    
export const getGetOpenAPIQueryOptions = <TData = Awaited<ReturnType<typeof getOpenAPI>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getOpenAPI>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOpenAPIQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOpenAPI>>> = ({ signal }) => getOpenAPI({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOpenAPI>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOpenAPIQueryResult = NonNullable<Awaited<ReturnType<typeof getOpenAPI>>>
export type GetOpenAPIQueryError = AxiosError<unknown>

/**
 * @summary Get the OpenAPI schema
 */
export const useGetOpenAPI = <TData = Awaited<ReturnType<typeof getOpenAPI>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getOpenAPI>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOpenAPIQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get the Swagger UI
 */
export const getSwaggerDocs = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/swagger-ui`,options
    );
  }


export const getGetSwaggerDocsQueryKey = () => {
    return [`/swagger-ui`] as const;
    }

    
export const getGetSwaggerDocsQueryOptions = <TData = Awaited<ReturnType<typeof getSwaggerDocs>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSwaggerDocs>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSwaggerDocsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSwaggerDocs>>> = ({ signal }) => getSwaggerDocs({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSwaggerDocs>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSwaggerDocsQueryResult = NonNullable<Awaited<ReturnType<typeof getSwaggerDocs>>>
export type GetSwaggerDocsQueryError = AxiosError<unknown>

/**
 * @summary Get the Swagger UI
 */
export const useGetSwaggerDocs = <TData = Awaited<ReturnType<typeof getSwaggerDocs>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSwaggerDocs>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSwaggerDocsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all projects
 */
export const getProjects = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Project[]>> => {
    
    return axios.get(
      `/project`,options
    );
  }


export const getGetProjectsQueryKey = () => {
    return [`/project`] as const;
    }

    
export const getGetProjectsQueryOptions = <TData = Awaited<ReturnType<typeof getProjects>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjects>>> = ({ signal }) => getProjects({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectsQueryResult = NonNullable<Awaited<ReturnType<typeof getProjects>>>
export type GetProjectsQueryError = AxiosError<unknown>

/**
 * @summary Get all projects
 */
export const useGetProjects = <TData = Awaited<ReturnType<typeof getProjects>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new project
 */
export const createProject = (
    createProjectBody: CreateProjectBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/project`,
      createProjectBody,options
    );
  }



export const getCreateProjectMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: CreateProjectBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: CreateProjectBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProject>>, {data: CreateProjectBody}> = (props) => {
          const {data} = props ?? {};

          return  createProject(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProjectMutationResult = NonNullable<Awaited<ReturnType<typeof createProject>>>
    export type CreateProjectMutationBody = CreateProjectBody
    export type CreateProjectMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a new project
 */
export const useCreateProject = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: CreateProjectBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createProject>>,
        TError,
        {data: CreateProjectBody},
        TContext
      > => {

      const mutationOptions = getCreateProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a project
 */
export const getProject = (
    projectId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Project>> => {
    
    return axios.get(
      `/project/${projectId}`,options
    );
  }


export const getGetProjectQueryKey = (projectId: string,) => {
    return [`/project/${projectId}`] as const;
    }

    
export const getGetProjectQueryOptions = <TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({ signal }) => getProject(projectId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectQueryResult = NonNullable<Awaited<ReturnType<typeof getProject>>>
export type GetProjectQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get a project
 */
export const useGetProject = <TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<ErrorResponse>>(
 projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectQueryOptions(projectId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all tasks for a project
 */
export const getProjectTasks = (
    projectId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Task[]>> => {
    
    return axios.get(
      `/project/${projectId}/tasks`,options
    );
  }


export const getGetProjectTasksQueryKey = (projectId: string,) => {
    return [`/project/${projectId}/tasks`] as const;
    }

    
export const getGetProjectTasksQueryOptions = <TData = Awaited<ReturnType<typeof getProjectTasks>>, TError = AxiosError<ErrorResponse>>(projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectTasks>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectTasksQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectTasks>>> = ({ signal }) => getProjectTasks(projectId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjectTasks>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectTasksQueryResult = NonNullable<Awaited<ReturnType<typeof getProjectTasks>>>
export type GetProjectTasksQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get all tasks for a project
 */
export const useGetProjectTasks = <TData = Awaited<ReturnType<typeof getProjectTasks>>, TError = AxiosError<ErrorResponse>>(
 projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectTasks>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectTasksQueryOptions(projectId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new task
 */
export const createTask = (
    projectId: string,
    createTaskBody: CreateTaskBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/project/${projectId}/tasks`,
      createTaskBody,options
    );
  }



export const getCreateTaskMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{projectId: string;data: CreateTaskBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{projectId: string;data: CreateTaskBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTask>>, {projectId: string;data: CreateTaskBody}> = (props) => {
          const {projectId,data} = props ?? {};

          return  createTask(projectId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTaskMutationResult = NonNullable<Awaited<ReturnType<typeof createTask>>>
    export type CreateTaskMutationBody = CreateTaskBody
    export type CreateTaskMutationError = AxiosError<unknown>

    /**
 * @summary Create a new task
 */
export const useCreateTask = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{projectId: string;data: CreateTaskBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createTask>>,
        TError,
        {projectId: string;data: CreateTaskBody},
        TContext
      > => {

      const mutationOptions = getCreateTaskMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a task
 */
export const getTask = (
    taskId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Task>> => {
    
    return axios.get(
      `/task/${taskId}`,options
    );
  }


export const getGetTaskQueryKey = (taskId: string,) => {
    return [`/task/${taskId}`] as const;
    }

    
export const getGetTaskQueryOptions = <TData = Awaited<ReturnType<typeof getTask>>, TError = AxiosError<unknown>>(taskId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTaskQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTask>>> = ({ signal }) => getTask(taskId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof getTask>>>
export type GetTaskQueryError = AxiosError<unknown>

/**
 * @summary Get a task
 */
export const useGetTask = <TData = Awaited<ReturnType<typeof getTask>>, TError = AxiosError<unknown>>(
 taskId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTaskQueryOptions(taskId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all runs for a task
 */
export const getTaskRuns = (
    taskId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Run[]>> => {
    
    return axios.get(
      `/task/${taskId}/run`,options
    );
  }


export const getGetTaskRunsQueryKey = (taskId: string,) => {
    return [`/task/${taskId}/run`] as const;
    }

    
export const getGetTaskRunsQueryOptions = <TData = Awaited<ReturnType<typeof getTaskRuns>>, TError = AxiosError<unknown>>(taskId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTaskRuns>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTaskRunsQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTaskRuns>>> = ({ signal }) => getTaskRuns(taskId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTaskRuns>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTaskRunsQueryResult = NonNullable<Awaited<ReturnType<typeof getTaskRuns>>>
export type GetTaskRunsQueryError = AxiosError<unknown>

/**
 * @summary Get all runs for a task
 */
export const useGetTaskRuns = <TData = Awaited<ReturnType<typeof getTaskRuns>>, TError = AxiosError<unknown>>(
 taskId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTaskRuns>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTaskRunsQueryOptions(taskId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new run for a task
 */
export const createRun = (
    taskId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/task/${taskId}/run`,undefined,options
    );
  }



export const getCreateRunMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRun>>, TError,{taskId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createRun>>, TError,{taskId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRun>>, {taskId: string}> = (props) => {
          const {taskId} = props ?? {};

          return  createRun(taskId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRunMutationResult = NonNullable<Awaited<ReturnType<typeof createRun>>>
    
    export type CreateRunMutationError = AxiosError<unknown>

    /**
 * @summary Create a new run for a task
 */
export const useCreateRun = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRun>>, TError,{taskId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createRun>>,
        TError,
        {taskId: string},
        TContext
      > => {

      const mutationOptions = getCreateRunMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all tools for a run
 */
export const getRunTools = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tool[]>> => {
    
    return axios.get(
      `/run/${runId}/tool`,options
    );
  }


export const getGetRunToolsQueryKey = (runId: string,) => {
    return [`/run/${runId}/tool`] as const;
    }

    
export const getGetRunToolsQueryOptions = <TData = Awaited<ReturnType<typeof getRunTools>>, TError = AxiosError<unknown>>(runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunTools>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunToolsQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunTools>>> = ({ signal }) => getRunTools(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRunTools>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRunToolsQueryResult = NonNullable<Awaited<ReturnType<typeof getRunTools>>>
export type GetRunToolsQueryError = AxiosError<unknown>

/**
 * @summary Get all tools for a run
 */
export const useGetRunTools = <TData = Awaited<ReturnType<typeof getRunTools>>, TError = AxiosError<unknown>>(
 runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunTools>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRunToolsQueryOptions(runId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new tool for a run
 */
export const createRunTool = (
    runId: string,
    createRunToolBody: CreateRunToolBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tool>> => {
    
    return axios.post(
      `/run/${runId}/tool`,
      createRunToolBody,options
    );
  }



export const getCreateRunToolMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRunTool>>, TError,{runId: string;data: CreateRunToolBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createRunTool>>, TError,{runId: string;data: CreateRunToolBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRunTool>>, {runId: string;data: CreateRunToolBody}> = (props) => {
          const {runId,data} = props ?? {};

          return  createRunTool(runId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRunToolMutationResult = NonNullable<Awaited<ReturnType<typeof createRunTool>>>
    export type CreateRunToolMutationBody = CreateRunToolBody
    export type CreateRunToolMutationError = AxiosError<unknown>

    /**
 * @summary Create a new tool for a run
 */
export const useCreateRunTool = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRunTool>>, TError,{runId: string;data: CreateRunToolBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createRunTool>>,
        TError,
        {runId: string;data: CreateRunToolBody},
        TContext
      > => {

      const mutationOptions = getCreateRunToolMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a supervisor
 */
export const getSupervisor = (
    supervisorId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Supervisor>> => {
    
    return axios.get(
      `/supervisor/${supervisorId}`,options
    );
  }


export const getGetSupervisorQueryKey = (supervisorId: string,) => {
    return [`/supervisor/${supervisorId}`] as const;
    }

    
export const getGetSupervisorQueryOptions = <TData = Awaited<ReturnType<typeof getSupervisor>>, TError = AxiosError<unknown>>(supervisorId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisor>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupervisorQueryKey(supervisorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupervisor>>> = ({ signal }) => getSupervisor(supervisorId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(supervisorId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSupervisor>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSupervisorQueryResult = NonNullable<Awaited<ReturnType<typeof getSupervisor>>>
export type GetSupervisorQueryError = AxiosError<unknown>

/**
 * @summary Get a supervisor
 */
export const useGetSupervisor = <TData = Awaited<ReturnType<typeof getSupervisor>>, TError = AxiosError<unknown>>(
 supervisorId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisor>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSupervisorQueryOptions(supervisorId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all supervisors
 */
export const getSupervisors = (
    projectId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Supervisor[]>> => {
    
    return axios.get(
      `/project/${projectId}/supervisor`,options
    );
  }


export const getGetSupervisorsQueryKey = (projectId: string,) => {
    return [`/project/${projectId}/supervisor`] as const;
    }

    
export const getGetSupervisorsQueryOptions = <TData = Awaited<ReturnType<typeof getSupervisors>>, TError = AxiosError<unknown>>(projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisors>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupervisorsQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupervisors>>> = ({ signal }) => getSupervisors(projectId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSupervisors>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSupervisorsQueryResult = NonNullable<Awaited<ReturnType<typeof getSupervisors>>>
export type GetSupervisorsQueryError = AxiosError<unknown>

/**
 * @summary Get all supervisors
 */
export const useGetSupervisors = <TData = Awaited<ReturnType<typeof getSupervisors>>, TError = AxiosError<unknown>>(
 projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisors>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSupervisorsQueryOptions(projectId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new supervisor
 */
export const createSupervisor = (
    projectId: string,
    supervisor: Supervisor, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/project/${projectId}/supervisor`,
      supervisor,options
    );
  }



export const getCreateSupervisorMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisor>>, TError,{projectId: string;data: Supervisor}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createSupervisor>>, TError,{projectId: string;data: Supervisor}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSupervisor>>, {projectId: string;data: Supervisor}> = (props) => {
          const {projectId,data} = props ?? {};

          return  createSupervisor(projectId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSupervisorMutationResult = NonNullable<Awaited<ReturnType<typeof createSupervisor>>>
    export type CreateSupervisorMutationBody = Supervisor
    export type CreateSupervisorMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a new supervisor
 */
export const useCreateSupervisor = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisor>>, TError,{projectId: string;data: Supervisor}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createSupervisor>>,
        TError,
        {projectId: string;data: Supervisor},
        TContext
      > => {

      const mutationOptions = getCreateSupervisorMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all supervisors for a tool, in chain format
 */
export const getToolSupervisorChains = (
    toolId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SupervisorChain[]>> => {
    
    return axios.get(
      `/tool/${toolId}/supervisors`,options
    );
  }


export const getGetToolSupervisorChainsQueryKey = (toolId: string,) => {
    return [`/tool/${toolId}/supervisors`] as const;
    }

    
export const getGetToolSupervisorChainsQueryOptions = <TData = Awaited<ReturnType<typeof getToolSupervisorChains>>, TError = AxiosError<unknown>>(toolId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getToolSupervisorChains>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetToolSupervisorChainsQueryKey(toolId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getToolSupervisorChains>>> = ({ signal }) => getToolSupervisorChains(toolId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(toolId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getToolSupervisorChains>>, TError, TData> & { queryKey: QueryKey }
}

export type GetToolSupervisorChainsQueryResult = NonNullable<Awaited<ReturnType<typeof getToolSupervisorChains>>>
export type GetToolSupervisorChainsQueryError = AxiosError<unknown>

/**
 * @summary Get all supervisors for a tool, in chain format
 */
export const useGetToolSupervisorChains = <TData = Awaited<ReturnType<typeof getToolSupervisorChains>>, TError = AxiosError<unknown>>(
 toolId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getToolSupervisorChains>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetToolSupervisorChainsQueryOptions(toolId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create new chains with supervisors for a tool
 */
export const createToolSupervisorChains = (
    toolId: string,
    chainRequest: ChainRequest[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string[]>> => {
    
    return axios.post(
      `/tool/${toolId}/supervisors`,
      chainRequest,options
    );
  }



export const getCreateToolSupervisorChainsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createToolSupervisorChains>>, TError,{toolId: string;data: ChainRequest[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createToolSupervisorChains>>, TError,{toolId: string;data: ChainRequest[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createToolSupervisorChains>>, {toolId: string;data: ChainRequest[]}> = (props) => {
          const {toolId,data} = props ?? {};

          return  createToolSupervisorChains(toolId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateToolSupervisorChainsMutationResult = NonNullable<Awaited<ReturnType<typeof createToolSupervisorChains>>>
    export type CreateToolSupervisorChainsMutationBody = ChainRequest[]
    export type CreateToolSupervisorChainsMutationError = AxiosError<unknown>

    /**
 * @summary Create new chains with supervisors for a tool
 */
export const useCreateToolSupervisorChains = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createToolSupervisorChains>>, TError,{toolId: string;data: ChainRequest[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createToolSupervisorChains>>,
        TError,
        {toolId: string;data: ChainRequest[]},
        TContext
      > => {

      const mutationOptions = getCreateToolSupervisorChainsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a tool call
 */
export const getToolCall = (
    toolCallId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SentinelToolCall>> => {
    
    return axios.get(
      `/tool_call/${toolCallId}`,options
    );
  }


export const getGetToolCallQueryKey = (toolCallId: string,) => {
    return [`/tool_call/${toolCallId}`] as const;
    }

    
export const getGetToolCallQueryOptions = <TData = Awaited<ReturnType<typeof getToolCall>>, TError = AxiosError<ErrorResponse>>(toolCallId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getToolCall>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetToolCallQueryKey(toolCallId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getToolCall>>> = ({ signal }) => getToolCall(toolCallId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(toolCallId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getToolCall>>, TError, TData> & { queryKey: QueryKey }
}

export type GetToolCallQueryResult = NonNullable<Awaited<ReturnType<typeof getToolCall>>>
export type GetToolCallQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get a tool call
 */
export const useGetToolCall = <TData = Awaited<ReturnType<typeof getToolCall>>, TError = AxiosError<ErrorResponse>>(
 toolCallId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getToolCall>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetToolCallQueryOptions(toolCallId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a tool call status
 */
export const getToolCallStatus = (
    toolCallId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Status>> => {
    
    return axios.get(
      `/tool_call/${toolCallId}/status`,options
    );
  }


export const getGetToolCallStatusQueryKey = (toolCallId: string,) => {
    return [`/tool_call/${toolCallId}/status`] as const;
    }

    
export const getGetToolCallStatusQueryOptions = <TData = Awaited<ReturnType<typeof getToolCallStatus>>, TError = AxiosError<unknown>>(toolCallId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getToolCallStatus>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetToolCallStatusQueryKey(toolCallId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getToolCallStatus>>> = ({ signal }) => getToolCallStatus(toolCallId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(toolCallId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getToolCallStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type GetToolCallStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getToolCallStatus>>>
export type GetToolCallStatusQueryError = AxiosError<unknown>

/**
 * @summary Get a tool call status
 */
export const useGetToolCallStatus = <TData = Awaited<ReturnType<typeof getToolCallStatus>>, TError = AxiosError<unknown>>(
 toolCallId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getToolCallStatus>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetToolCallStatusQueryOptions(toolCallId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a tool
 */
export const getTool = (
    toolId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tool>> => {
    
    return axios.get(
      `/tool/${toolId}`,options
    );
  }


export const getGetToolQueryKey = (toolId: string,) => {
    return [`/tool/${toolId}`] as const;
    }

    
export const getGetToolQueryOptions = <TData = Awaited<ReturnType<typeof getTool>>, TError = AxiosError<ErrorResponse>>(toolId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTool>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetToolQueryKey(toolId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTool>>> = ({ signal }) => getTool(toolId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(toolId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTool>>, TError, TData> & { queryKey: QueryKey }
}

export type GetToolQueryResult = NonNullable<Awaited<ReturnType<typeof getTool>>>
export type GetToolQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get a tool
 */
export const useGetTool = <TData = Awaited<ReturnType<typeof getTool>>, TError = AxiosError<ErrorResponse>>(
 toolId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTool>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetToolQueryOptions(toolId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all tools for a project
 */
export const getProjectTools = (
    projectId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tool[]>> => {
    
    return axios.get(
      `/project/${projectId}/tools`,options
    );
  }


export const getGetProjectToolsQueryKey = (projectId: string,) => {
    return [`/project/${projectId}/tools`] as const;
    }

    
export const getGetProjectToolsQueryOptions = <TData = Awaited<ReturnType<typeof getProjectTools>>, TError = AxiosError<unknown>>(projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectTools>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectToolsQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectTools>>> = ({ signal }) => getProjectTools(projectId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjectTools>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectToolsQueryResult = NonNullable<Awaited<ReturnType<typeof getProjectTools>>>
export type GetProjectToolsQueryError = AxiosError<unknown>

/**
 * @summary Get all tools for a project
 */
export const useGetProjectTools = <TData = Awaited<ReturnType<typeof getProjectTools>>, TError = AxiosError<unknown>>(
 projectId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectTools>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectToolsQueryOptions(projectId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a supervision request for a supervisor in a chain on a tool call
 */
export const createSupervisionRequest = (
    toolCallId: string,
    chainId: string,
    supervisorId: string,
    supervisionRequest: SupervisionRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/tool_call/${toolCallId}/chain/${chainId}/supervisor/${supervisorId}/supervision_request`,
      supervisionRequest,options
    );
  }



export const getCreateSupervisionRequestMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisionRequest>>, TError,{toolCallId: string;chainId: string;supervisorId: string;data: SupervisionRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createSupervisionRequest>>, TError,{toolCallId: string;chainId: string;supervisorId: string;data: SupervisionRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSupervisionRequest>>, {toolCallId: string;chainId: string;supervisorId: string;data: SupervisionRequest}> = (props) => {
          const {toolCallId,chainId,supervisorId,data} = props ?? {};

          return  createSupervisionRequest(toolCallId,chainId,supervisorId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSupervisionRequestMutationResult = NonNullable<Awaited<ReturnType<typeof createSupervisionRequest>>>
    export type CreateSupervisionRequestMutationBody = SupervisionRequest
    export type CreateSupervisionRequestMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a supervision request for a supervisor in a chain on a tool call
 */
export const useCreateSupervisionRequest = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisionRequest>>, TError,{toolCallId: string;chainId: string;supervisorId: string;data: SupervisionRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createSupervisionRequest>>,
        TError,
        {toolCallId: string;chainId: string;supervisorId: string;data: SupervisionRequest},
        TContext
      > => {

      const mutationOptions = getCreateSupervisionRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a supervision request status
 */
export const getSupervisionRequestStatus = (
    supervisionRequestId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SupervisionStatus>> => {
    
    return axios.get(
      `/supervision_request/${supervisionRequestId}/status`,options
    );
  }


export const getGetSupervisionRequestStatusQueryKey = (supervisionRequestId: string,) => {
    return [`/supervision_request/${supervisionRequestId}/status`] as const;
    }

    
export const getGetSupervisionRequestStatusQueryOptions = <TData = Awaited<ReturnType<typeof getSupervisionRequestStatus>>, TError = AxiosError<unknown>>(supervisionRequestId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisionRequestStatus>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupervisionRequestStatusQueryKey(supervisionRequestId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupervisionRequestStatus>>> = ({ signal }) => getSupervisionRequestStatus(supervisionRequestId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(supervisionRequestId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSupervisionRequestStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSupervisionRequestStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getSupervisionRequestStatus>>>
export type GetSupervisionRequestStatusQueryError = AxiosError<unknown>

/**
 * @summary Get a supervision request status
 */
export const useGetSupervisionRequestStatus = <TData = Awaited<ReturnType<typeof getSupervisionRequestStatus>>, TError = AxiosError<unknown>>(
 supervisionRequestId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisionRequestStatus>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSupervisionRequestStatusQueryOptions(supervisionRequestId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a supervision result
 */
export const getSupervisionResult = (
    supervisionRequestId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SupervisionResult>> => {
    
    return axios.get(
      `/supervision_request/${supervisionRequestId}/result`,options
    );
  }


export const getGetSupervisionResultQueryKey = (supervisionRequestId: string,) => {
    return [`/supervision_request/${supervisionRequestId}/result`] as const;
    }

    
export const getGetSupervisionResultQueryOptions = <TData = Awaited<ReturnType<typeof getSupervisionResult>>, TError = AxiosError<unknown>>(supervisionRequestId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisionResult>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupervisionResultQueryKey(supervisionRequestId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupervisionResult>>> = ({ signal }) => getSupervisionResult(supervisionRequestId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(supervisionRequestId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSupervisionResult>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSupervisionResultQueryResult = NonNullable<Awaited<ReturnType<typeof getSupervisionResult>>>
export type GetSupervisionResultQueryError = AxiosError<unknown>

/**
 * @summary Get a supervision result
 */
export const useGetSupervisionResult = <TData = Awaited<ReturnType<typeof getSupervisionResult>>, TError = AxiosError<unknown>>(
 supervisionRequestId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisionResult>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSupervisionResultQueryOptions(supervisionRequestId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a supervision result for a supervision request
 */
export const createSupervisionResult = (
    supervisionRequestId: string,
    supervisionResult: SupervisionResult, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.post(
      `/supervision_request/${supervisionRequestId}/result`,
      supervisionResult,options
    );
  }



export const getCreateSupervisionResultMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisionResult>>, TError,{supervisionRequestId: string;data: SupervisionResult}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createSupervisionResult>>, TError,{supervisionRequestId: string;data: SupervisionResult}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSupervisionResult>>, {supervisionRequestId: string;data: SupervisionResult}> = (props) => {
          const {supervisionRequestId,data} = props ?? {};

          return  createSupervisionResult(supervisionRequestId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSupervisionResultMutationResult = NonNullable<Awaited<ReturnType<typeof createSupervisionResult>>>
    export type CreateSupervisionResultMutationBody = SupervisionResult
    export type CreateSupervisionResultMutationError = AxiosError<unknown>

    /**
 * @summary Create a supervision result for a supervision request
 */
export const useCreateSupervisionResult = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupervisionResult>>, TError,{supervisionRequestId: string;data: SupervisionResult}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createSupervisionResult>>,
        TError,
        {supervisionRequestId: string;data: SupervisionResult},
        TContext
      > => {

      const mutationOptions = getCreateSupervisionResultMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the state of a run
 */
export const getRunState = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RunState>> => {
    
    return axios.get(
      `/run/${runId}/state`,options
    );
  }


export const getGetRunStateQueryKey = (runId: string,) => {
    return [`/run/${runId}/state`] as const;
    }

    
export const getGetRunStateQueryOptions = <TData = Awaited<ReturnType<typeof getRunState>>, TError = AxiosError<unknown>>(runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunState>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunStateQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunState>>> = ({ signal }) => getRunState(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRunState>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRunStateQueryResult = NonNullable<Awaited<ReturnType<typeof getRunState>>>
export type GetRunStateQueryError = AxiosError<unknown>

/**
 * @summary Get the state of a run
 */
export const useGetRunState = <TData = Awaited<ReturnType<typeof getRunState>>, TError = AxiosError<unknown>>(
 runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunState>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRunStateQueryOptions(runId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a run
 */
export const getRun = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Run>> => {
    
    return axios.get(
      `/run/${runId}`,options
    );
  }


export const getGetRunQueryKey = (runId: string,) => {
    return [`/run/${runId}`] as const;
    }

    
export const getGetRunQueryOptions = <TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<ErrorResponse>>(runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRun>>> = ({ signal }) => getRun(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRunQueryResult = NonNullable<Awaited<ReturnType<typeof getRun>>>
export type GetRunQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get a run
 */
export const useGetRun = <TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<ErrorResponse>>(
 runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRunQueryOptions(runId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get the status of a run
 */
export const getRunStatus = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Status>> => {
    
    return axios.get(
      `/run/${runId}/status`,options
    );
  }


export const getGetRunStatusQueryKey = (runId: string,) => {
    return [`/run/${runId}/status`] as const;
    }

    
export const getGetRunStatusQueryOptions = <TData = Awaited<ReturnType<typeof getRunStatus>>, TError = AxiosError<ErrorResponse>>(runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunStatus>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunStatusQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunStatus>>> = ({ signal }) => getRunStatus(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRunStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRunStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getRunStatus>>>
export type GetRunStatusQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get the status of a run
 */
export const useGetRunStatus = <TData = Awaited<ReturnType<typeof getRunStatus>>, TError = AxiosError<ErrorResponse>>(
 runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunStatus>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRunStatusQueryOptions(runId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update the status of a run
 */
export const updateRunStatus = (
    runId: string,
    status: Status, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `/run/${runId}/status`,
      status,options
    );
  }



export const getUpdateRunStatusMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRunStatus>>, TError,{runId: string;data: Status}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateRunStatus>>, TError,{runId: string;data: Status}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRunStatus>>, {runId: string;data: Status}> = (props) => {
          const {runId,data} = props ?? {};

          return  updateRunStatus(runId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRunStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateRunStatus>>>
    export type UpdateRunStatusMutationBody = Status
    export type UpdateRunStatusMutationError = AxiosError<unknown>

    /**
 * @summary Update the status of a run
 */
export const useUpdateRunStatus = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRunStatus>>, TError,{runId: string;data: Status}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateRunStatus>>,
        TError,
        {runId: string;data: Status},
        TContext
      > => {

      const mutationOptions = getUpdateRunStatusMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Update a run with a result
 */
export const updateRunResult = (
    runId: string,
    updateRunResultBody: UpdateRunResultBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.put(
      `/run/${runId}/result`,
      updateRunResultBody,options
    );
  }



export const getUpdateRunResultMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRunResult>>, TError,{runId: string;data: UpdateRunResultBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateRunResult>>, TError,{runId: string;data: UpdateRunResultBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRunResult>>, {runId: string;data: UpdateRunResultBody}> = (props) => {
          const {runId,data} = props ?? {};

          return  updateRunResult(runId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRunResultMutationResult = NonNullable<Awaited<ReturnType<typeof updateRunResult>>>
    export type UpdateRunResultMutationBody = UpdateRunResultBody
    export type UpdateRunResultMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update a run with a result
 */
export const useUpdateRunResult = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRunResult>>, TError,{runId: string;data: UpdateRunResultBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updateRunResult>>,
        TError,
        {runId: string;data: UpdateRunResultBody},
        TContext
      > => {

      const mutationOptions = getUpdateRunResultMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get hub stats
 */
export const getHubStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<HubStats>> => {
    
    return axios.get(
      `/stats`,options
    );
  }


export const getGetHubStatsQueryKey = () => {
    return [`/stats`] as const;
    }

    
export const getGetHubStatsQueryOptions = <TData = Awaited<ReturnType<typeof getHubStats>>, TError = AxiosError<ErrorResponse>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHubStats>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHubStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHubStats>>> = ({ signal }) => getHubStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHubStats>>, TError, TData> & { queryKey: QueryKey }
}

export type GetHubStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getHubStats>>>
export type GetHubStatsQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get hub stats
 */
export const useGetHubStats = <TData = Awaited<ReturnType<typeof getHubStats>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHubStats>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetHubStatsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get the review payload for a supervision request
 */
export const getSupervisionReviewPayload = (
    supervisionRequestId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReviewPayload>> => {
    
    return axios.get(
      `/supervision_request/${supervisionRequestId}/review_payload`,options
    );
  }


export const getGetSupervisionReviewPayloadQueryKey = (supervisionRequestId: string,) => {
    return [`/supervision_request/${supervisionRequestId}/review_payload`] as const;
    }

    
export const getGetSupervisionReviewPayloadQueryOptions = <TData = Awaited<ReturnType<typeof getSupervisionReviewPayload>>, TError = AxiosError<ErrorResponse>>(supervisionRequestId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisionReviewPayload>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupervisionReviewPayloadQueryKey(supervisionRequestId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupervisionReviewPayload>>> = ({ signal }) => getSupervisionReviewPayload(supervisionRequestId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(supervisionRequestId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSupervisionReviewPayload>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSupervisionReviewPayloadQueryResult = NonNullable<Awaited<ReturnType<typeof getSupervisionReviewPayload>>>
export type GetSupervisionReviewPayloadQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get the review payload for a supervision request
 */
export const useGetSupervisionReviewPayload = <TData = Awaited<ReturnType<typeof getSupervisionReviewPayload>>, TError = AxiosError<ErrorResponse>>(
 supervisionRequestId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupervisionReviewPayload>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSupervisionReviewPayloadQueryOptions(supervisionRequestId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new chat completion request from an existing run
 */
export const createNewChat = (
    runId: string,
    sentinelChat: SentinelChat, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ChatIds>> => {
    
    return axios.post(
      `/run/${runId}/chat`,
      sentinelChat,options
    );
  }



export const getCreateNewChatMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNewChat>>, TError,{runId: string;data: SentinelChat}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createNewChat>>, TError,{runId: string;data: SentinelChat}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNewChat>>, {runId: string;data: SentinelChat}> = (props) => {
          const {runId,data} = props ?? {};

          return  createNewChat(runId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNewChatMutationResult = NonNullable<Awaited<ReturnType<typeof createNewChat>>>
    export type CreateNewChatMutationBody = SentinelChat
    export type CreateNewChatMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a new chat completion request from an existing run
 */
export const useCreateNewChat = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNewChat>>, TError,{runId: string;data: SentinelChat}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof createNewChat>>,
        TError,
        {runId: string;data: SentinelChat},
        TContext
      > => {

      const mutationOptions = getCreateNewChatMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the messages for a run
 */
export const getRunMessages = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SentinelMessage[]>> => {
    
    return axios.get(
      `/run/${runId}/messages`,options
    );
  }


export const getGetRunMessagesQueryKey = (runId: string,) => {
    return [`/run/${runId}/messages`] as const;
    }

    
export const getGetRunMessagesQueryOptions = <TData = Awaited<ReturnType<typeof getRunMessages>>, TError = AxiosError<ErrorResponse>>(runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunMessages>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunMessagesQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunMessages>>> = ({ signal }) => getRunMessages(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRunMessages>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRunMessagesQueryResult = NonNullable<Awaited<ReturnType<typeof getRunMessages>>>
export type GetRunMessagesQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get the messages for a run
 */
export const useGetRunMessages = <TData = Awaited<ReturnType<typeof getRunMessages>>, TError = AxiosError<ErrorResponse>>(
 runId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRunMessages>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRunMessagesQueryOptions(runId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get the state of a tool call
 */
export const getToolCallState = (
    toolCallId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RunExecution>> => {
    
    return axios.get(
      `/tool_call/${toolCallId}/state`,options
    );
  }


export const getGetToolCallStateQueryKey = (toolCallId: string,) => {
    return [`/tool_call/${toolCallId}/state`] as const;
    }

    
export const getGetToolCallStateQueryOptions = <TData = Awaited<ReturnType<typeof getToolCallState>>, TError = AxiosError<unknown>>(toolCallId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getToolCallState>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetToolCallStateQueryKey(toolCallId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getToolCallState>>> = ({ signal }) => getToolCallState(toolCallId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(toolCallId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getToolCallState>>, TError, TData> & { queryKey: QueryKey }
}

export type GetToolCallStateQueryResult = NonNullable<Awaited<ReturnType<typeof getToolCallState>>>
export type GetToolCallStateQueryError = AxiosError<unknown>

/**
 * @summary Get the state of a tool call
 */
export const useGetToolCallState = <TData = Awaited<ReturnType<typeof getToolCallState>>, TError = AxiosError<unknown>>(
 toolCallId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getToolCallState>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetToolCallStateQueryOptions(toolCallId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




