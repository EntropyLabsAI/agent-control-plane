/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Sentinel API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
export type GetLLMPrompt200 = {
  prompt?: string;
};

export interface Project {
  id: string;
  name: string;
  tools: Tool[];
}

export interface RegisterProjectResponse {
  id: string;
}

export interface RegisterProjectRequest {
  name: string;
  tools: Tool[];
}

export interface LLMPromptResponse {
  message: string;
  status: string;
}

export interface LLMPrompt {
  prompt: string;
}

export type HubStatsReviewDistribution = {[key: string]: number};

export type HubStatsAssignedReviews = {[key: string]: number};

export interface HubStats {
  assigned_reviews: HubStatsAssignedReviews;
  busy_clients: number;
  completed_reviews: number;
  connected_clients: number;
  free_clients: number;
  queued_reviews: number;
  review_distribution: HubStatsReviewDistribution;
  stored_reviews: number;
}

export type Status = typeof Status[keyof typeof Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Status = {
  queued: 'queued',
  processing: 'processing',
  completed: 'completed',
  timeout: 'timeout',
} as const;

export type Decision = typeof Decision[keyof typeof Decision];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Decision = {
  approve: 'approve',
  reject: 'reject',
  escalate: 'escalate',
  terminate: 'terminate',
  modify: 'modify',
} as const;

export interface Usage {
  input_tokens: number;
  output_tokens: number;
  total_tokens: number;
}

export type ToolCallArguments = { [key: string]: unknown };

export interface ToolCall {
  arguments: ToolCallArguments;
  function: string;
  id: string;
  parse_error?: string;
  type: string;
}

export interface AssistantMessage {
  content: string;
  role: string;
  source?: string;
  tool_calls?: ToolCall[];
}

export interface Choice {
  message: AssistantMessage;
  stop_reason?: string;
}

export interface Output {
  choices?: Choice[];
  model?: string;
  usage?: Usage;
}

export interface Arguments {
  cmd?: string;
  code?: string;
}

export interface ToolChoice {
  arguments: Arguments;
  function: string;
  id: string;
  type: string;
}

export type ToolAttributes = { [key: string]: unknown };

export interface Tool {
  attributes?: ToolAttributes;
  description?: string;
  name: string;
}

export interface Message {
  content: string;
  function?: string;
  role: string;
  source?: string;
  tool_call_id?: string;
  tool_calls?: ToolCall[];
}

export type TaskStateStore = { [key: string]: unknown };

export type TaskStateMetadata = { [key: string]: unknown };

export interface TaskState {
  completed: boolean;
  messages: Message[];
  metadata?: TaskStateMetadata;
  output: Output;
  store?: TaskStateStore;
  tool_choice?: ToolChoice;
  tools: Tool[];
}

export interface ErrorResponse {
  status: string;
}

export interface ReviewResult {
  decision: Decision;
  id: string;
  reasoning: string;
  tool_choice: ToolChoice;
}

export interface ReviewStatusResponse {
  id: string;
  status: Status;
}

export interface ReviewRequest {
  agent_id: string;
  last_messages: Message[];
  task_state: TaskState;
  tool_choices: ToolChoice[];
}

export interface Review {
  id: string;
  request: ReviewRequest;
}

export interface LLMExplanation {
  explanation: string;
  score: number;
}

export interface CodeSnippet {
  text: string;
}





/**
 * @summary Register a new project
 */
export const registerProject = (
    registerProjectRequest: RegisterProjectRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Project>> => {
    
    return axios.post(
      `/api/project`,
      registerProjectRequest,options
    );
  }



export const getRegisterProjectMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerProject>>, TError,{data: RegisterProjectRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof registerProject>>, TError,{data: RegisterProjectRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerProject>>, {data: RegisterProjectRequest}> = (props) => {
          const {data} = props ?? {};

          return  registerProject(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterProjectMutationResult = NonNullable<Awaited<ReturnType<typeof registerProject>>>
    export type RegisterProjectMutationBody = RegisterProjectRequest
    export type RegisterProjectMutationError = AxiosError<unknown>

    /**
 * @summary Register a new project
 */
export const useRegisterProject = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerProject>>, TError,{data: RegisterProjectRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof registerProject>>,
        TError,
        {data: RegisterProjectRequest},
        TContext
      > => {

      const mutationOptions = getRegisterProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all projects
 */
export const getProjects = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RegisterProjectResponse[]>> => {
    
    return axios.get(
      `/api/project`,options
    );
  }


export const getGetProjectsQueryKey = () => {
    return [`/api/project`] as const;
    }

    
export const getGetProjectsQueryOptions = <TData = Awaited<ReturnType<typeof getProjects>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjects>>> = ({ signal }) => getProjects({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectsQueryResult = NonNullable<Awaited<ReturnType<typeof getProjects>>>
export type GetProjectsQueryError = AxiosError<unknown>

/**
 * @summary Get all projects
 */
export const useGetProjects = <TData = Awaited<ReturnType<typeof getProjects>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a project by ID
 */
export const getProjectById = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/project/${id}`,options
    );
  }


export const getGetProjectByIdQueryKey = (id: string,) => {
    return [`/api/project/${id}`] as const;
    }

    
export const getGetProjectByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProjectById>>, TError = AxiosError<unknown>>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectById>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectById>>> = ({ signal }) => getProjectById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjectById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProjectById>>>
export type GetProjectByIdQueryError = AxiosError<unknown>

/**
 * @summary Get a project by ID
 */
export const useGetProjectById = <TData = Awaited<ReturnType<typeof getProjectById>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectById>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Submit a review to a human supervisor
 */
export const submitReviewHuman = (
    reviewRequest: ReviewRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReviewStatusResponse>> => {
    
    return axios.post(
      `/api/review/human`,
      reviewRequest,options
    );
  }



export const getSubmitReviewHumanMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitReviewHuman>>, TError,{data: ReviewRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof submitReviewHuman>>, TError,{data: ReviewRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitReviewHuman>>, {data: ReviewRequest}> = (props) => {
          const {data} = props ?? {};

          return  submitReviewHuman(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubmitReviewHumanMutationResult = NonNullable<Awaited<ReturnType<typeof submitReviewHuman>>>
    export type SubmitReviewHumanMutationBody = ReviewRequest
    export type SubmitReviewHumanMutationError = AxiosError<unknown>

    /**
 * @summary Submit a review to a human supervisor
 */
export const useSubmitReviewHuman = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitReviewHuman>>, TError,{data: ReviewRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof submitReviewHuman>>,
        TError,
        {data: ReviewRequest},
        TContext
      > => {

      const mutationOptions = getSubmitReviewHumanMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all LLM review results
 */
export const getLLMReviews = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Review[]>> => {
    
    return axios.get(
      `/api/review/llm`,options
    );
  }


export const getGetLLMReviewsQueryKey = () => {
    return [`/api/review/llm`] as const;
    }

    
export const getGetLLMReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getLLMReviews>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLLMReviews>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLLMReviewsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLLMReviews>>> = ({ signal }) => getLLMReviews({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLLMReviews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLLMReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getLLMReviews>>>
export type GetLLMReviewsQueryError = AxiosError<unknown>

/**
 * @summary Get all LLM review results
 */
export const useGetLLMReviews = <TData = Awaited<ReturnType<typeof getLLMReviews>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLLMReviews>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetLLMReviewsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Submit a review to an LLM supervisor
 */
export const submitReviewLLM = (
    reviewRequest: ReviewRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReviewStatusResponse>> => {
    
    return axios.post(
      `/api/review/llm`,
      reviewRequest,options
    );
  }



export const getSubmitReviewLLMMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitReviewLLM>>, TError,{data: ReviewRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof submitReviewLLM>>, TError,{data: ReviewRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitReviewLLM>>, {data: ReviewRequest}> = (props) => {
          const {data} = props ?? {};

          return  submitReviewLLM(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubmitReviewLLMMutationResult = NonNullable<Awaited<ReturnType<typeof submitReviewLLM>>>
    export type SubmitReviewLLMMutationBody = ReviewRequest
    export type SubmitReviewLLMMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Submit a review to an LLM supervisor
 */
export const useSubmitReviewLLM = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitReviewLLM>>, TError,{data: ReviewRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof submitReviewLLM>>,
        TError,
        {data: ReviewRequest},
        TContext
      > => {

      const mutationOptions = getSubmitReviewLLMMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get review status
 */
export const getReviewStatus = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReviewResult>> => {
    
    return axios.get(
      `/api/review/status/${id}`,options
    );
  }


export const getGetReviewStatusQueryKey = (id: string,) => {
    return [`/api/review/status/${id}`] as const;
    }

    
export const getGetReviewStatusQueryOptions = <TData = Awaited<ReturnType<typeof getReviewStatus>>, TError = AxiosError<ErrorResponse>>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getReviewStatus>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewStatusQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewStatus>>> = ({ signal }) => getReviewStatus(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type GetReviewStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewStatus>>>
export type GetReviewStatusQueryError = AxiosError<ErrorResponse>

/**
 * @summary Get review status
 */
export const useGetReviewStatus = <TData = Awaited<ReturnType<typeof getReviewStatus>>, TError = AxiosError<ErrorResponse>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getReviewStatus>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetReviewStatusQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Submit a new prompt for LLM reviews
 */
export const setLLMPrompt = (
    lLMPrompt: LLMPrompt, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LLMPromptResponse>> => {
    
    return axios.post(
      `/api/review/llm/prompt`,
      lLMPrompt,options
    );
  }



export const getSetLLMPromptMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setLLMPrompt>>, TError,{data: LLMPrompt}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof setLLMPrompt>>, TError,{data: LLMPrompt}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setLLMPrompt>>, {data: LLMPrompt}> = (props) => {
          const {data} = props ?? {};

          return  setLLMPrompt(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetLLMPromptMutationResult = NonNullable<Awaited<ReturnType<typeof setLLMPrompt>>>
    export type SetLLMPromptMutationBody = LLMPrompt
    export type SetLLMPromptMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Submit a new prompt for LLM reviews
 */
export const useSetLLMPrompt = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setLLMPrompt>>, TError,{data: LLMPrompt}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof setLLMPrompt>>,
        TError,
        {data: LLMPrompt},
        TContext
      > => {

      const mutationOptions = getSetLLMPromptMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the current LLM review prompt
 */
export const getLLMPrompt = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetLLMPrompt200>> => {
    
    return axios.get(
      `/api/review/llm/prompt`,options
    );
  }


export const getGetLLMPromptQueryKey = () => {
    return [`/api/review/llm/prompt`] as const;
    }

    
export const getGetLLMPromptQueryOptions = <TData = Awaited<ReturnType<typeof getLLMPrompt>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLLMPrompt>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLLMPromptQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLLMPrompt>>> = ({ signal }) => getLLMPrompt({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLLMPrompt>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLLMPromptQueryResult = NonNullable<Awaited<ReturnType<typeof getLLMPrompt>>>
export type GetLLMPromptQueryError = AxiosError<unknown>

/**
 * @summary Get the current LLM review prompt
 */
export const useGetLLMPrompt = <TData = Awaited<ReturnType<typeof getLLMPrompt>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLLMPrompt>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetLLMPromptQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get hub statistics
 */
export const getHubStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<HubStats>> => {
    
    return axios.get(
      `/api/hub/stats`,options
    );
  }


export const getGetHubStatsQueryKey = () => {
    return [`/api/hub/stats`] as const;
    }

    
export const getGetHubStatsQueryOptions = <TData = Awaited<ReturnType<typeof getHubStats>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHubStats>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHubStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHubStats>>> = ({ signal }) => getHubStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHubStats>>, TError, TData> & { queryKey: QueryKey }
}

export type GetHubStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getHubStats>>>
export type GetHubStatsQueryError = AxiosError<unknown>

/**
 * @summary Get hub statistics
 */
export const useGetHubStats = <TData = Awaited<ReturnType<typeof getHubStats>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHubStats>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetHubStatsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get an explanation and danger score for a code snippet
 */
export const getLLMExplanation = (
    codeSnippet: CodeSnippet, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LLMExplanation>> => {
    
    return axios.post(
      `/api/explain`,
      codeSnippet,options
    );
  }



export const getGetLLMExplanationMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getLLMExplanation>>, TError,{data: CodeSnippet}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getLLMExplanation>>, TError,{data: CodeSnippet}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getLLMExplanation>>, {data: CodeSnippet}> = (props) => {
          const {data} = props ?? {};

          return  getLLMExplanation(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetLLMExplanationMutationResult = NonNullable<Awaited<ReturnType<typeof getLLMExplanation>>>
    export type GetLLMExplanationMutationBody = CodeSnippet
    export type GetLLMExplanationMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Get an explanation and danger score for a code snippet
 */
export const useGetLLMExplanation = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getLLMExplanation>>, TError,{data: CodeSnippet}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof getLLMExplanation>>,
        TError,
        {data: CodeSnippet},
        TContext
      > => {

      const mutationOptions = getGetLLMExplanationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the API documentation
 */
export const getSwaggerDocs = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/docs`,options
    );
  }


export const getGetSwaggerDocsQueryKey = () => {
    return [`/api/docs`] as const;
    }

    
export const getGetSwaggerDocsQueryOptions = <TData = Awaited<ReturnType<typeof getSwaggerDocs>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSwaggerDocs>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSwaggerDocsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSwaggerDocs>>> = ({ signal }) => getSwaggerDocs({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSwaggerDocs>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSwaggerDocsQueryResult = NonNullable<Awaited<ReturnType<typeof getSwaggerDocs>>>
export type GetSwaggerDocsQueryError = AxiosError<unknown>

/**
 * @summary Get the API documentation
 */
export const useGetSwaggerDocs = <TData = Awaited<ReturnType<typeof getSwaggerDocs>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSwaggerDocs>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSwaggerDocsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get the OpenAPI schema
 */
export const getOpenAPI = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/openapi.yaml`,options
    );
  }


export const getGetOpenAPIQueryKey = () => {
    return [`/api/openapi.yaml`] as const;
    }

    
export const getGetOpenAPIQueryOptions = <TData = Awaited<ReturnType<typeof getOpenAPI>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getOpenAPI>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOpenAPIQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOpenAPI>>> = ({ signal }) => getOpenAPI({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOpenAPI>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOpenAPIQueryResult = NonNullable<Awaited<ReturnType<typeof getOpenAPI>>>
export type GetOpenAPIQueryError = AxiosError<unknown>

/**
 * @summary Get the OpenAPI schema
 */
export const useGetOpenAPI = <TData = Awaited<ReturnType<typeof getOpenAPI>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getOpenAPI>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOpenAPIQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




